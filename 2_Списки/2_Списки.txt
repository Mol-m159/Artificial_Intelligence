Списки
Молчановой Ю. О., 02161-ДМ
В файле формата docx есть скриншоты выводов программы.


Вариант 5
Запрос: 
Сформировать новый список, в котором каждый элемент исходного списка входит в новый список два раза подряд.

constr([], []).
constr([HP | TP], [HP,HP | TR]) :-constr(TP, TR).

Решением задачи является наш заданный список, где каждый элемент продублирован рядом. Пустой массив вернёт нам пустой массив.

Процедурная интерпретация: 
1.	Чтобы продублировать каждый элемент нужно:
2.	Задать 2 списка: основной и дублированный. При вызове функции constr/2 мы дважды помещаем элемент HP в начало списка, после рекурсивно вызываем constr с телами 2-ух списков.


Вариант 9
Запрос: 
Подсчитать количество элементов списка.

list_length([], 0).
list_length([_|T], L) :- list_length(T, L1), L is L1+1.

Декларативная интерпретация: 
Решением задачи будет число входящих в список элементов, если элементов нет, то вернётся 0.
Процедурная интерпретация: 
1.	Чтобы получить длину списка нужно:
2.	Перевызывать правило list_length/2, с хвостом списка и новой переменной L1, которая является L изменённой на +1.
3.	Вызовы будут происходить до тех пор, пока не встретиться конец списка.


Вариант 11
Запрос:
Упорядочить список методом вставки.

my_sort(L, SL):- my_sort(L, [], SL).
my_sort([], SL, SL):-!.
my_sort([H|T], SP, SL):- in(H, SP, SPH),my_sort(T, SPH, SL).

in(X, [], [X]):-!.
in(X, [H|T], [X, H|T]):- X < H, !.
in(X, [H|T], [H|IT]):- in(X, T, IT).

Декларативная интерпретация: 
Решением задачи будет список, сортированные по методы вставок, путём разбиения на 2 списка. L-начальный список, SL - Конечный сортированный список.
Если исходный список пуст, то результатом является список из вставляемого элемента.

Процедурная операция: Чтобы отсортировать список, нужно учесть:
1.	Если первый элемент списка меньше вставляемого — новый элемент добавляется в начало списка.
2.	В остальных случаях от списка отделяется первый элемент, остальные обрабатываются рекурсивно.
3.	К полученному результату добавляется ранее вытащенный первый элемент.

Идея такова, что исходный список разделяется на две части — упорядоченную и необработанную.
Так как в упорядоченной части нет элементов, вводим функцию вставки элемента. Если элементы в необработанной части закончились — функция возвращает упорядоченную часть в качестве результата. Иначе первый элемент неупорядоченной части вставляется в отсортированную при помощи функции in.  Полученный в результате список обрабатывается рекурсивно.
